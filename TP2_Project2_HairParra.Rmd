---
header-includes:
  - \usepackage{amsmath}
  - \usepackage{amssymb}
  - \usepackage{amsthm}
  - \usepackage{fancyhdr}
  - \pagestyle{fancy}
  - \fancyfoot[CO,CE]{Hair Parra, Alessio Bessan, Ioan Catalin}
  - \fancyfoot[LE,RO]{\thepage}
title: "TP2 Risk Management"
author: 'TP2: Hair Parra , Alessio Bressan, Ioan Catalin'
date: "`r Sys.Date()`"
geometry: margin=1.3cm
output: 
    pdf_document: 
      extra_dependencies: ["array", "amsmath","booktabs"]
---

<!--These are definitions of Latex Environments--> 
\newtheorem{assumption}{Assumption}[assumption]
\newtheorem{theorem}{Theorem}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{example}{Example}
\newtheorem{remark*}{Remark}
\newtheorem{exercise*}{Exercise}


```{r setup, include=FALSE}
# additional setup options
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=9, fig.height=6) 

# configurations for plot 
my_plot_hook <- function(x, options)
  paste("\n", knitr::hook_plot_tex(x, options), "\n")
knitr::knit_hooks$set(plot = my_plot_hook)

# numeric format 
options("scipen" = 10)
```

### Libraries 

```{r, message=FALSE, echo=FALSE}
# Preload R libraries we will use 
library(here)
library(xts) 
library(zoo)
library(quantmod)

# additional source code
source(here("code", "NormalCopulaPdf.R")) # compute the pdf of a normal copula
source(here("code", "StudentCopulaPdf.R")) # compute the pdf of a normal copula
source(here("code", "DisplayCopula.R")) # display the pdf through a 3-d chart
```


# Risk Management: European Options Portfolio

The objective is to implement (part of) the risk management framework for estimating the risk of a book of European call options by taking into account the risk drivers such as underlying and implied volatility.

## Data 

Load the database Market. Identify the price of the **SP500**, the **VIX index**, the term structure of interest rates (current and past), and the traded options (calls and puts).

```{r}
# load dataset into environment
load(file = here("data_raw", "Market.rda"))

# reassign name and inspect structure of loaded data 
mkt <- Market 
summary(mkt)
```

```{r}
str(mkt)
```

Let's unpack these into the env. individually: 

```{r}
# unpack each of the elements in the mkt list
sp500 <- mkt$sp500
vix <- mkt$vix 
Rf <- mkt$rf # risk-free rates
calls <- mkt$calls 
puts <- mkt$puts 

# assign colname for aesthetic
colnames(sp500) <- "sp500"
colnames(vix) <- "vix"
```

**SP500 and VIX** 

By inspection, we observe that we the SP500 and VIX indices are contained in the `sp500` and `vix` xts objects respectively. 

```{r}
# show head of both indexes 
head(sp500) 
head(vix)
```

```{r fig.height=8, fig.width=8, fig.align='center'}
par(mfrow = c(2,1)) 

# plot both series on top of each other 
plot(sp500) 
plot(vix)
```


**Interest Rates** 

The **interest rates** are given in the `$rf` attribute. We can see that 

```{r}
Rf
```
These represent the interest rates at different maturities. The maturities are given as follows:

```{r}
r_f <- as.vector(Rf)
names(r_f) <- c("1d","1w", "1m", "3m", "6m", "9m", "1y", "2y", "3y", "4y", "5y", "7y","10y", "30y")
r_f
```

Further, we can pack different sources of information in a matrix: 

```{r}
# pack Rf into a matrix with rf, years, and days
rf_mat <- as.matrix(r_f)
rf_mat <- cbind(rf_mat, as.numeric(names(Rf)))
rf_mat <- cbind(rf_mat, rf_mat[, 2]*360)
colnames(rf_mat) <- c("rf", "years", "days") 
rf_mat
```

```{r, echo=FALSE}
# turn into dataframe
rf_df <- data.frame(rf_mat)
rf_df$years2 <- rf_df$years**2 
rf_df$years3 <- rf_df$years**3

# perform linear regresison 
rf_lm <- lm(rf ~ 1 + years + years2 + years3, data = rf_df)

# obtain predictions
preds <- predict(rf_lm)

# extract index 
x <- rf_df$years
ix  <- sort(x, index.return=T)$ix

# 
plot(x, rf_df$rf, 
     main="Term Structure of Risk-Free Rates", 
     xlab = "Years", 
     ylab="Rf", 
     col="blue",
     type="p",
     pch=16, 
     cex=1.2
     )

# add polynomial curve to plot 
lines(x[ix], preds[ix], col='black', lwd=2)
grid()
```


**Calls** 

The `calls` object displays the different values of $K$ (**Strike Price**), $\tau$ (**time to maturity**) and $\sigma = IV$ (**Implied Volatilty**)

```{r}
dim(calls)
head(calls)
```
Add `days` column for convenience: 

```{r}
calls <- cbind(calls, calls[, "tau"]*250)
colnames(calls) <- c("K","tau", "IV", "tau_days")
head(calls)
tail(calls)
```

**Puts** 

```{r}
dim(puts)
head(puts)
```

```{r}
puts <- cbind(puts, puts[, "tau"]*250)
colnames(puts) <- c("K","tau", "IV", "tau_days")
head(puts)
tail(puts)
```

## Pricing a Portfolio of Options 

### Black-Scholes 

Notation: 

- $S_t$ = Current value of underlying asset price
- $K$ = Options **strike price** 
- $T$ = Option **maturity** (in years) 
- $t$ = **time** in years
- $\tau$ = $T-t$ = **Time to maturity** 
- $r$ = **Risk-free rate** 
- $y$ **Dividend yield**
- $R$ = $r-y$ 
- $\sigma$ = **Implied volatility** 
- $c$ = **Price Call Option** 
- $p$ = **Price Put Option** 

\begin{proposition}[Black-Scholes Model] 
Assume the notation before, and let $N(\cdot)$ be the cumulative standard normal distribution function. Under certain assumptions, the Black-Scholes models prices Call and Put options as follows: 
$$
\begin{cases}
C(S_t, t) = Se^{yT} N(d_1) - Ke^{-r \times \tau} N(d_2), \\ 
\; \\
P(S_t, t) = Ke^{-r \times \tau}(1 - N(d_2))  - Se^{y \times T}(1-N(d_1)), 
\end{cases}
$$

where: 
$$
\begin{cases} 
d_1 = \dfrac{\ln\left( \dfrac{S_t}{K} \right) + \tau\left( r + \dfrac{\sigma^2}{2}  \right)}{\sigma \sqrt{\tau}} \\ 
d_2 = d_1 - \sigma \sqrt{\tau} \\ 
\end{cases}
$$
, further the Put Option price corresponds to the **Put-Call parity**, given by: 

$$
C(S_t, t) + Ke^{-r \times \tau} = P(S_t, t) + S_{t}
$$

\end{proposition}

**Note** As here we don't have dividends, then $y=0$, and so 

$$
\begin{cases}
C(S_t, t) = S_tN(d_1) - Ke^{-r \times \tau} N(d_2), \\ 
\; \\
P(S_t, t) = Ke^{-r \times \tau}(1 - N(d_2))  - S_t(1-N(d_1)), 
\end{cases}
$$

### Implementation 

```{r}
get_d1 <- function(S_t, K, tau, r, sigma){ 
  ### Compute d1 for the Black-Scholes model 
  # INPUTS
  #   S_t:  Current value of underlying asset price
  #   K:    Strike Price
  #   tau:  T- t, where T=maturity, and t=current time
  #   r:    risk-free rate 
  #   sigma   Implied volatility (i.e. sigma)
  
  num <- (log(S_t/K) - tau*(r + 0.5*sigma**2)) # numerator
  denom <- sigma * sqrt(tau) # denominator 
  
  return(num/denom)
}

get_d2 <- function(d1, sigma, tau){
  ### Compute d2 for the Black-Scholes model 
  # INPUTS
  #   d1:  d1 factor calculated by the get_d1 function
  #   tau:  T- t, where T=maturity, and t=current time
  #   sigma   Implied volatility (i.e. sigma)
  
  return(d1 - sigma * sqrt(tau))
}

# Function to implement the Black-Scholes model 
black_scholes <- function(S_t, K, r, tau, sigma, put=FALSE){
  # Calculates a Call (or Option) price using Black-Scholes
  # INPUTS
  #   S_t:     [numeric] Current value of underlying asset price
  #   K:       [numeric] Strike Price
  #   r:       [numeric] risk-free rate 
  #   tau:     [numeric] T- t, where T=maturity, and t=current time
  #   sigma:   [numeric] Implied volatility (i.e. sigma)
  #   put:     [logical] if TRUE, calculate a Put, if FALSE, calculate a Call. 
  #            FALSE by default (Call). 
  # 
  # OUTPUTS: 
  #   P or C: [numeric] Option value according to Black-scholes
  
  # calculate d1 & d2
  d1 <- get_d1(S_t, K, tau, r, sigma)
  d2 <- get_d2(d1, sigma, tau)
  
  if(put==TRUE){ 
    # calculate a Put option 
    P <- K*exp(-r*tau)*(1 - pnorm(d2)) - S_t * (1 - pnorm(d1))
    P <- as.numeric(P)
    return( round(P,6))
  }
  # else calculate a Call option (default) 
  C <- S_t * pnorm(d1) - K*exp(-r*tau) * pnorm(d2)
  return( round(as.numeric(C),6) )
}

# Test: Call Option 
S_t = 1540
K = 1600 
r = 0.03
tau = 10/360 
sigma = 1.05
black_scholes(S_t, K, r, tau, sigma)
```

## Book of Options

Assume the following book of **European Call Options:** 

1. **1x** strike $K=1600$ with maturity $T=20d$ 
2. **1x** strike $K=1605$ with maturity $T=40d$
3. **1x** strike $K=1800$ with maturity $T=40d$ 

Find the price of this book given **the last underlying price** and the **last implied volatility** (take the VIX for all options). Use **Black-Scholes** to price the options. Take the current term structure and **linearly interpolate** to find the corresponding rates. Use 360 days/year for the term structure and **250 days/year** for the maturity of the options. 

### Nearest values 

This function will obtain the two nearest values $a, b$ for a number $x$ in a vector $v$, such that $a<x<b$. 

```{r}
# Obtain the two nearest values of x in vec.
get_nearest<- function(x, vec){ 
  # find all the numbers that are bigger and smaller than x in vec 
  bigger <- vec >= x 
  smaller <- vec <= x
  
  # filter only values with TRUE 
  bigger <- bigger[bigger == TRUE]
  smaller <- smaller[smaller == TRUE]
  
  # obtain the indexes for the left and upper bound
  a_idx <- length(smaller)
  b_idx <- length(smaller)+1
  
  # retrieve values from original vector 
  a <- vec[a_idx]
  b <- vec[b_idx]
  
  # return the retrieved values 
  return( c(a,b) )
}

# Test 
days <- rf_mat[, "days"]
get_nearest(40, rf_mat[, "days"]) # nearest day values 
```

### Linear Interpolation

Given two known values $(x_1, y_1)$ and $(x_2, y_2)$, we can estimate the $y$-value for some $x$-value with:

$$
y = y_1 + \dfrac{(x-x_1)(y_2-y_1)}{(x_2-x_1)}
$$

```{r}
# Function to interpolate y given two points
interpolate <- function(x,x1=1,y1=1,x2=2,y2=2){
  y1 + (x-x1)*(y2-y1)/(x2-x1)
}
```


### Finding the rates through interpolation 

The **yield curve** for the given structure of interest rates can be modeled a function $r_f = f(x)$ ,where $x$ is the number of years. Then, we can interapolate the values as follows: 

```{r}
# Interest rates
rf_mat
```

```{r}
head(calls)
```

ex.: **1x** strike $K=1600$ with maturity $T=20d$ 

```{r}
price_option <- function(T, K, calls, rf_mat, stock=NA, S_t=NA, IV = NA, put=FALSE){ 
  # Calculates the price of an European option using input parameters
  # INPUTS
  #   T:        [numeric] maturity of option (in days)
  #   K:        [numeric] Strike Price
  #   calls:    [matrix] matrix containing information about tau and IV for different strike prices
  #   rf_mat:       [matrix] matrix containing risk-free term structure
  #   stock:     [xts OR zoo like object] object containing stock prices for a single stock
  #   S_t:      [numeric] Specific price at time t 
  #   IV:    [float] Implied volatility of the underlying 
  #   put:     [logical] if TRUE, calculate a Put, if FALSE, calculate a Call. 
  #            FALSE by default (Call). 
  # 
  # OUTPUTS: 
  #   LIST containing: 
  #     - P or C: [numeric] Option value according to Black-scholes and available information
  #     - r_interp: [numeric] Interpolated risk-free rate given risk-free term structure
  #     - calls [matrix] relevant set of calls information 
  #     - rates [matrix] relevant set of risk-free rates used for the interpolation
  
  # Sanity check 
  if(!is.matrix(calls) | !('tau_days' %in% colnames(calls)) ){
    stop("calls should be a matrix with columns c('K', 'tau', 'IV', 'tau_days')")
  }
  
  # Inputs
  tau = T/250 # days --> years 
  days_calls <- calls[,"tau_days"] # extract days column
  days_rf <- rf_mat[, "days"] # extract days from rf_mat
  
  # extract the calls values 
  ab <- get_nearest(T, days_calls) # search lower and upper nearest days to T
  valid_days <- calls[, "tau_days"] == ab[1] | calls[, "tau_days"] == ab[2] # where match
  calls_sub <- calls[ valid_days,  ] # subset valid rows
  calls_sub <- calls_sub[calls_sub[,"K"]==K, ] # subset matching K 
  
  # test whether matrix is empty (i.e. no matching K found)
  if(all(is.na(calls_sub))){
    warning("No values matching K in Calls data\n")
  }

  # extract interpolated risk rates 
  ab <- get_nearest(T, days_rf) # obtain nearest days to T available in rf_mat 
  valid_days_rf <- rf_mat[, "days"] == ab[1] | rf_mat[, "days"] == ab[2] # where match
  rates <- rf_mat[valid_days_rf, ] # subset for valid days 

  # interpolate risk free rate for Option given maturity 
  r <- interpolate(tau, 
                   x1=rates[1,2], 
                   y1=rates[1,1], 
                   x2=rates[2,2], 
                   y2=rates[2,1])

  # use provided sigma by default, else calculate from calls matrix
  if(is.na(sigma)){
    
    # retrieve implied volatility for option 
    if(is.matrix(calls_sub)){
      # average between lower and upper values 
      sigma <- (calls_sub[1, "IV"] + calls_sub[2, "IV"])/2
      
    } else{
      # retrive from numeric vector (single match)
      sigma <- calls_sub["IV"]
    }
    
  }
  else{ 
    # rename for convenience
    sigma <- IV
  }
  
  # if price at t is not provided
  if(is.na(S_t) & !is.na(stock)){
    # retrieve last price for option from input index
    warning("Using last day's S_t from input index\n")
    S_t <- as.numeric( stock[length(stock)])
  }
  
  # Calculate Option price 
  if(put==TRUE){
    C <- NA
    P <- black_scholes(S_t, K, r, tau, sigma, put=TRUE)
  }
  else{ 
    C <- black_scholes(S_t, K, r, tau, sigma, put=FALSE)
    P <- NA
  }
  
  # pack everything into a List and return 
  return(list(Call = C, 
              Put = P, 
              S = as.numeric(S_t)[[1]], 
              K = K, 
              r_interp = r, 
              calls = calls_sub, # subset of calls used
              rates = rates # subset of rates used 
              ))
}
```

```{r}
S_t = sp500[length(sp500)] # last price of underlying 
IV = vix[length(vix)] # last volatility 

## test: specific price 
price_option(T=20, K=1600, calls = calls, rf_mat =  rf_mat, stock = NA, S_t = S_t, IV = IV)
```


Next, using the function above we price the book of options given: 

1. **1x** strike $K=1600$ with maturity $T=20d$ 
2. **1x** strike $K=1605$ with maturity $T=40d$
3. **1x** strike $K=1800$ with maturity $T=40d$ 

First, we retrieve the latest value for the underlying (SP500) and the latest implied volatility (VIX): 

```{r}
S_t = sp500[length(sp500)] # last price of underlying 
IV = vix[length(vix)] # last volatility 
```

Then, we price the options accordingly: 
 
```{r}
# First Call Option 
price_option(T=20, K=1600, calls=calls, rf_mat=rf_mat, S_t = S_t, IV = IV)
```

```{r}
# Second Call Option 
price_option(T=40, K=1605, calls=calls, rf_mat=rf_mat, S_t = S_t, IV = IV)
```

```{r}
# Third Call Option 
price_option(T=40, K=1800, calls=calls, rf_mat=rf_mat, S_t = S_t, IV = IV)
```

## Two risk drivers and copula-marginal model (Student-t and Gaussian Copula) 

1. Compute the daily log-returns of the underlying stock 
2. Assume the first invariant is generated using a Student-t distribution with $\nu=10$ df and the second invariant is generated using a Student-t distribution with $\nu=5$ df.
3. Assume the **normal copula** to merge the marginals. 
4. Generate 10000 scenarios for the one-week ahead price for the underlying and the one-week ahead VIX value using the copula. 
5. Determine the P&L distribution of the book of options, using the simulated values. 
6. Take interpolated rates for the term structure.  

### Location-scale Student-t distribution 

The location-scale model of the Student-t distribution with density function $f_{t}(x; \mu, \sigma, \nu)$ as:

$$
f_{t}(x; \mu, \sigma, \nu) 
= 
\dfrac{1}{\sigma} f_{t}\left(\dfrac{x\ - \mu}{\sigma}; \nu\right), 
$$

where: 

$$
f_{t}(z, \nu) 
= \dfrac{\Gamma\left(\frac{\nu +1}{2} \right) }{\sqrt{\nu\pi} \Gamma \left(\frac{\nu}{2}\right)  }
\left( 1  +\dfrac{z^2}{\nu}  \right)^{-\frac{\nu+1}{2}}
$$

### Gaussian Copula with two Student-t marginals

A bivariate distribution $H$ can be formed via a copula $C$ from two marginal distributions with CDFs $F$ and $G$ via:

$$
H(x,y) = C(F(x), G(y)) = C(F^{-1}(u), G^{-1}(u))
$$

with density 

$$
h(x,y) = c(F(x), G(y))f(x)g(y)
$$

The **Gaussian Copula** is given by: 

$$
C^{\text{Gauss}}_{\rho}(u,v) = \Phi_{\rho}(\Phi^{-1}(u), \Phi^{-1}(v)).
$$

In this case, a Gaussian copula with two Student-t marginals with CDFs $t(\nu_1)$ with $\nu_1$ degrees of freedom and $t(\nu_2)$ with $\nu_2$ degrees of freedom is given by:

$$
C^{\text{Gauss}}_{\rho}(u,v) = \Phi_{\rho}(F_{\nu_1}^{-1}(u), F_{\nu_1}^{-1}(v)), 
$$
where $F_{\nu_1}$ and $F_{\nu_2}$ are their respective CDFs. 


### Log-returns 

```{r, message=FALSE}
# load reqruired libraries 
library("PerformanceAnalytics")

# calculate returns
sp500_rets <- PerformanceAnalytics::CalculateReturns(sp500, method="log")
vix_rets <- PerformanceAnalytics::CalculateReturns(vix, method="log")

# remove nas 
sp500_rets <- sp500_rets[rowSums(is.na(sp500_rets)) == 0,]
vix_rets <- vix_rets[rowSums(is.na(vix_rets)) == 0,]

# display
head(sp500_rets) 
head(vix_rets)
```

### Generating the simulation scenarios 

Assumptions: 
- Marginal Student-t distributions 
- Disregard time dependence in the bootstrapping process 


```{r,message=FALSE}
# Load required libraries 
library("fGarch")
library("MASS")
library("Matrix")

# random seed for replication 
set.seed(69)

# Simulation parameters
n_sim = 10000 # set number of simulations
n_ahead = 5 # days aheade to produce samples 

# vector version since ignoring dates and using full past data
sp500_rets_vec <- as.vector(sp500_rets) 
vix_rets_vec <- as.vector(vix_rets)

# preallocate matrices to store simulations
sim_rets_sp500 <- matrix(NA, nrow = n_sim, ncol=5)
sim_rets_vix <- matrix(NA, nrow = n_sim, ncol=5)

# assign days ahead 
colnames(sim_rets_sp500) <- c("T+1", "T+2", "T+3", "T+4", "T+5")
colnames(sim_rets_vix) <- c("T+1", "T+2", "T+3", "T+4", "T+5")

# perform simulations 
for(b in 1:n_sim){
  
  # # Obtain the bootstrapped samples from the data (?) >-- not sure if this is right? 
  # b_sp500 <- sample(sp500_vec, size=length(sp500_vec), replace=TRUE)
  # b_vix <- sample(vix_vec, size=length(vix_vec), replace=TRUE)
  
  # straight up fit on the data 
  b_sp500 <- sp500_rets_vec 
  b_vix <- vix_rets_vec
  
  ##  Fit a Gaussian Copula to model the dependence 
  
  # calculate the mean vector 
  mu <- c(mean(b_sp500), mean(b_vix))
  
  # calculate the covariance 
  r <- cor(b_sp500, b_vix)[[1]] # correlation coefficient 
  sig <- c(sd(b_sp500), sd(b_vix)) # standard deviation
  R <- matrix(data = c(1, r, r, 1), # correlation matrix
              nrow = 2,
              ncol = 2,
              byrow = TRUE)
  Sigma <- diag(sig) %*% R %*% diag(sig) # covariance matrix
  Sigma <- (Sigma + t(Sigma)) / 2
  Sigma <- as.matrix(nearPD(Sigma)$mat)
  
  # Sample 5-days ahead from Gaussian Copula
  Z <- mvrnorm(n = n_ahead, mu = mu, Sigma = Sigma)

  # Draws from Gaussian Copula
  U1 <- pnorm(q = Z[, 1], mu[1], sig[1]) # first dimension (sp500)
  U2 <- pnorm(q = Z[, 2], mu[2], sig[2]) # second dimension  (vix)
  
  # Model marginals with student-t distributions & sample
  X1 <- qt(U1, df = 10) # simulated sp500
  X2 <- qt(U2, df = 5) # simulated vix
  
  # store simulation of log return in matrix 
  sim_rets_sp500[b, ] <- X1 
  sim_rets_vix[b ,] <- X2
}

# preview of simulated log returns 
head(sim_rets_sp500)
head(sim_rets_vix)
```

Next, we crate a function to forecast the 5 day ahead prices from the returns

```{r}
f_return_to_price <- function(p0, forecasted_rets)
{
  
  # p0: initial price
  # forecasted_rets: matrix of forecasted returns
  
  forecasted_prices = matrix(NA, nrow(forecasted_rets), ncol(forecasted_rets))
  temp = p0
  
  for(i in 1:nrow(forecasted_rets))
  {
    for(j in 1:ncol(forecasted_rets))
    {
      forecasted_prices[i,j] = exp(log(temp) + forecasted_rets[i,j])
    }
    temp = forecasted_prices[i,j]
  }
  
  # assign colnames
  colnames(forecasted_prices) <- c("T+1", "T+2", "T+3", "T+4", "T+5")
  
  return(forecasted_prices)
}
```

```{r}
# Obtain Initial values (last value of simulation) 
spT <- sp500[length(sp500)] 
vixT <- vix[length(vix)] 

# Convert back to price and to vix values 
sim_price_sp500 <- f_return_to_price(spT, sim_rets_sp500)
sim_vol_vix <- f_return_to_price(vixT, sim_rets_vix)

# compare simulated returns with the price
head(sim_rets_sp500)
head(sim_price_sp500) 
```

```{r}
# compare simualted log rets with volatility 
head(sim_rets_vix)
head(sim_vol_vix)
```

### Pricing the simulation scenarios 

Recall the initial (call) options: 

1. **1x** strike $K=1600$ with maturity $T=20d$ 
2. **1x** strike $K=1605$ with maturity $T=40d$
3. **1x** strike $K=1800$ with maturity $T=40d$ 

**Helper Functions**

First, we code a function that will compute the option price, and an auxiliary function to create empty matrices of corresponding sizes: 

```{r}
prc_opt <- function(T, K, calls, rf_mat, price_vec, vol_vec){ 
  #### Wrapper for price_option for two vectors of prices and volatilities 
  # 
  # INPUTS
  #   T:            [numeric] time to maturity
  #   calls:        [matrix] matrix containing information about tau and IV for different strike prices
  #   rf_mat:       [matrix] matrix containing risk-free term structure
  #   price_vec:    [numeric vector] vector of stock (sp500) prices
  #   vol_vec:      [numeric vector] vector of corresponding volatilities 
  # 
  # OUTPUTS: 
  #   opt prices: [numeric vector] vector of option prices  
  
  # abstract price_opt function two arguments: S_t and IV 
  price_opt_abstr <- function(x,y){price_option(T=T, # maturity
                                                K=K, # strike 
                                                calls, # calls matrix 
                                                rf_mat, # matrix of risk free structure
                                                stock = NA, # ignore 
                                                S_t = x, # specific price
                                                IV = y)$Call} # implied volatility + extract Call price
  
  # pack both vectors into a dataframe 
  vec_df <- data.frame(price_vec, vol_vec) 
  
  # Calculate the options for all input S_t  and corresponding volatilities
  opt_prices <- mapply(price_opt_abstr, vec_df$price_vec, vec_df$vol_vec)
  
  return(opt_prices)
}

initialize_sim_mats <- function(sim_mat, lnames=NULL, num_mats=3){
  #### Initializesa list of (num_mats) many matrices of same size as sim_mat with NA entries
  # 
  # INPUTS
  #   sim_mat:    [matrix] (n_sim x n_days_ahead) matrix of simulation prices for 
  #               n_days ahead, with n_sim simulations. 
  #   lnames:     [character vector] vector with names for each of the created matrices 
  #   num_mats:   [numeric] number of matrices to create 
  # 
  # OUTPUT: 
  #   mats:       [list of matrices] List containing three matrices of compatible sizes as sim_mat
  #               initialized to NA  values
  
  
  # P/L of book of options 
  mats <- lapply(rep(1, num_mats), # generate three empty matrices of compatible sizes
                    function(x){
                      matrix(NA, 
                             nrow(sim_mat), 
                             ncol(sim_mat),
                             dimnames=list(seq(1:nrow(sim_mat)),
                                           c("T+1", "T+2", "T+3", "T+4", "T+5")
                                           )
                             )
                      }
                    )
  
  # assign column names 
  if(!is.null(lnames)){
    names(mats) <- lnames
  }
  
  return(mats)
}
```

**Option Pricing of Simulated Values**

Next, we calculate the price of the book of options for the simulated values. 

```{r}
# random seed for replication 
set.seed(123)

# Initialize empty matrices to store the simulated option prices (aka premiums)
opt_price_mats <- initialize_sim_mats(sim_price_sp500, 
                                       lnames = c("opt1", "opt2", "opt3"),
                                       num_mats = 3
                                       )

#  maturities for each of the options
T1 <- 20
T2 <- 40
T3 <- 40

# Strikes for the options 
K1 <- 1600 
K2 <- 1605 
K3 <- 1800

# looop through simulated prices (n_ahead days)
for(t in 1:ncol(sim_price_sp500)){
  
  # extract simulated prices for sp500 at T+t
  prices_t <- sim_price_sp500[, t] 
  
  # extract implied volatility from vix at T+t 
  vols_t <- sim_vol_vix[, t]
  
  # price first Call option
  c1_vec <- prc_opt(T1-t, K1, calls, rf_mat, prices_t, vols_t)
  opt_price_mats$opt1[ ,t] <- c1_vec
  # print(cbind(prices_t, vols_t, c1_vec)) # <-- uncomment for debugging
  
  # price first Call option
  c2_vec <- prc_opt(T2-t, K2, calls, rf_mat, prices_t, vols_t)
  opt_price_mats$opt2[ ,t] <- c2_vec
  
  # price first Call option
  c3_vec <- prc_opt(T3-t, K3, calls, rf_mat, prices_t, vols_t)
  opt_price_mats$opt3[ ,t] <- c3_vec
}
```

```{r}
# overview of dataframes
head(opt_price_mats$opt1)
head(opt_price_mats$opt2)
head(opt_price_mats$opt3)
```

### Distribution of the Profit and Loss for the Book Of Options 

Recall the profit functions for European options: 

### Parameters 

**Parameters:** 
- $S$: Spot price (current)
- $S_0$: Spot price at the beginnin of the option
- $S_T$: Spot price at maturity
- $T$: Maturity of option
- $K$: Strike price
- $c$: Price of Call option
- $p$: Price of Put option


### Profit at Maturity

The profit functions of a long call and a long put are given by: 

$$
\begin{aligned}
\pi^{\text{Long Call}} = \max(S_T - K, 0) - c \\ 
\pi^{\text{Long Put}} = \max(K - S_T, 0) - p
\end{aligned}
$$

**Option profit function** 

```{r}
option_profit <- function(S,K,c=NULL, p=NULL, short=FALSE, N=1){
  #### Calculates Call and or Put profits
  # 
  # INPUTS
  #   S:          [numeric or vector] array of prices to use 
  #   K:          [numeric] Strike price for the option 
  #   c:          [numeric or vector] array of premiums for a Call option
  #   sim_mat:    [matrix] (n_sim x n_days_ahead) matrix of simulation prices for 
  #               n_days ahead, with n_sim simulations. 
  #   lnames:     [character vector] vector with names for each of the created matrices 
  #   num_mats:   [numeric] number of matrices to create 
  # 
  # OUTPUT: 
  #   mats:       [list of matrices] List containing three matrices of compatible sizes as sim_mat
  #               initialized to NA  values
  
  # Initialize empty profit values 
  profits <- list(call_profit=NA, put_profit=NA)
  call_profit = NA
  put_profit = NA
  
  # sanity check 
  if(is.null(c) & is.null(p)){
    stop("At least one of c or p must be provided") 
  }
  
  # if c, calculate the Call profit 
  if(!is.null(c)){
    profits$call_profit <- (max(S - K, 0) - c)*N
  }
  
  # if p, calculate the Put profit 
  if(!is.null(p)){
    profits$put_profit <- (max(K - S, 0) - p)*N
  }
  
  # inverse profit if short position 
  if(short){
    profits <- lapply(profits, function(x){-x})
  }
  
  # multiply by size 
  return(profits)
}
```

**Calculating the profits** 

For each of the simulated prices and resulting premiums, we want to calculate the profit generated at each simulation timestep: 

```{r}
# Matrices of profit and loss for each of the options simulations 
PL_mats <- initialize_sim_mats(sim_price_sp500, 
                                       lnames = c("PL1", "PL2", "PL3"),
                                       num_mats = 3
                                       )

# Calculate profit for all simulated options at each day ahead
for(t in 1:n_ahead){
  
  #spot price of underlying at day T+t
  spot <- sim_price_sp500[, t]
  
  # Option profit for K1 at time T+t with premiums c1
  c1 <- opt_price_mats$opt1[, t] # extract the premiums
  PL_mats$PL1[,t] <- option_profit(S=spot, K=K1, c=c1)$call_profit
  
  print(head(c1))
  print(head(spot))
  
  break
  
  # # Option profit for K1 at time T+t with premiums c2
  # c2 <- opt_price_mats$opt2[, t] # extract the premiums
  # PL_mats$PL2[,t] <- option_profit(S=spot, K=K2, c=c2)$call_profit
  # 
  # # Option profit for K1 at time T+t with premiums c1
  # c3 <- opt_price_mats$opt3[, t] # extract the premiums
  # PL_mats$PL3[,t] <- option_profit(S=spot, K=K3, c=c3)$call_profit
}
```

```{r}
# display profit matrices 
head(PL_mats$PL1)
head(PL_mats$PL2)
head(PL_mats$PL3)
```

**Distribution of Options P/L** 

Next, using all the simulated profits and losses for each of the options, we display a histogram for the distribution for each of the options, for the aggregated 5 days of simulation: 

```{r fig.height=12, fig.width=8, fig.align='center'}
# flatten the matrices 5-days ahead simulated P/L for the three options 
sim_pl_opt1 <- as.vector(PL_mats$PL1)
sim_pl_opt2 <- as.vector(PL_mats$PL2)
sim_pl_opt3 <- as.vector(PL_mats$PL3)

# plot the distribution for each of the options 
par(mfrow = c(3,1))
hist(sim_pl_opt1, nclass = round(10 * log(n_sim)), probability = TRUE)
hist(sim_pl_opt2, nclass = round(10 * log(n_sim)), probability = TRUE)
hist(sim_pl_opt3, nclass = round(10 * log(n_sim)), probability = TRUE)
```








