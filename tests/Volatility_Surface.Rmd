#Volatility Surface

Upload libraries
```{r}
library("here")

source(here("code", "OptionPricing.R"))
```

Load data
```{r}
load(here("data_raw", "Market.rda"))

S <- Market$sp500[length(Market$sp500)][[1]] #3410
VIX <- as.numeric(Market$vix[length(Market$vix)])

calls <- Market$calls

puts <- Market$puts

# convert to draframe for easier manipulation 
calls_df <- as.data.frame(calls)
puts_df <- as.data.frame(puts)

# assign extra column to puts (1) and calls (0)
calls_df["type"] <- "call"
puts_df["type"] <- "put"

# check dimensions 
dim(calls_df) 
dim(puts_df)

# stack both of these matrices together 
puts_calls <- rbind(calls_df, puts_df) 

# integrate the price 
puts_calls["S"] <- rep(S, nrow(puts_calls))
puts_calls["m"] <- puts_calls["K"]/puts_calls["S"]

# filter the calls that have moniness over one 
calls_m_over <- puts_calls[(puts_calls["type"] == "call") & (puts_calls["m"] >= 1), ]

# filter the puts that have moniness below one
puts_m_under <- puts_calls[(puts_calls["type"] == "put") & (puts_calls["m"] < 1), ]

# combine these results into putcalls again 
call_put_data <- rbind(calls_m_over, puts_m_under)

head(call_put_data)
```

Parametric Surface
```{r}
f_sig <- function(alpha, m, t){
  #m is an array of K/S
  #t is a repetitive array same tau for K
  #IV is a vector or numbers
  #alpha is a set of paramters
  a1 <- alpha[1]
  a2 <- alpha[2]
  a3 <- alpha[3]
  a4 <- alpha[4]
  
  sig <- a1 + a2*(m-1)^2 + a3*(m-1)^3 + a4*sqrt(t)
  
  return(sig)
}

f_fit <- function(alpha, m, t, IV){
  
  sig <- f_sig(alpha, m, t)
  error <- abs(IV - sig)
  
  return(sum(error))
}
```

Optimize the function

```{r}
#Initialization
start <- c(1, 1, 0, 1)

test <- f_fit(start, m = call_put_data$m[1:100],
                    t = call_put_data$tau[1:100],
                    IV = call_put_data$IV[1:100])

#Optimize
fit <- optim(par = start,
             fn = f_fit,
             method = "BFGS",
             m = call_put_data$m,
             t = call_put_data$tau,
             IV = call_put_data$IV)

#optimal parameters
alpha <- fit$par

#delta of the VIX
VIX_model <- fit$par[1] + fit$par[4]
distance <- VIX - VIX_model
distance
```


Volatility Curve Plot

```{r}
Moneyness <- call_put_data$m
Time <- call_put_data$tau
IV <- as.matrix(f_sig(alpha, Moneyness, Time))

##THE PLOT I HAVE NO IDEA HOW TO DO IT
plot_ly(x=~Moneyness, y=~Time, z=~IV) %>% add_surface() %>%
    layout(title = "Option Vol Surface")


```
Re-price the portfolio in one week assuming the same parametric model but shifted by the VIX difference

There is a distance between the model and the data, we need to keep the same distance and project it forward

```{r}
#Simulate the foward path for the VIX at the 5 day horizon assuming both normal distributions
load(here("data_out","simulated_VIX.rda"))
#sim_data

#Lets say we take the mean of all the bootstrapped data to predict the VIX a week ahead
VIX_sim <- colMeans(sim_data)[5]

#re-calibrate the VIX_model
VIX_model
VIX_model2 <- VIX_sim - distance

sim_fit <- solnp(alpha, fun = f_fit, eqfun = f_constraint, eqB = 0,
                 m = call_put_data$m,
                 t = call_put_data$tau,
                 IV = call_put_data$IV)


```



